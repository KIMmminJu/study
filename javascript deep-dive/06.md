# 데이터 타입
- 데이터 타입은 값의 종류를 말하며, 자바스크립트 모든 값은 데이터 타입을 갖는다. 
- 자바스크립트는 7개의 데이터 타입을 제공하며, **원시타입 / 객체 타입**으로 분류할 수 있다.

|구분|데이터 타입|설명|
|---|---|---|
|원시타입|숫자타입|숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재|
||문자열 타입|문자열|
||불린 타입|논리적 참과 거짓|
||undefined 타입|var 키워드로 선언된 변수에 암묵적으로 할당되는 값|
||null 타입|값이 없다는 것을 의도적으로 명시할 때 사용하는 값|
||심볼 타입|객체의 프로퍼티 키를 고유하게 설정함으로써 프로퍼티 키의 충돌을 방지하기 위해 사용|
|객체타입||객체,함수,배열 등|

>> 예를 들어 숫자 타입 값 1과 문자열 타입의 '1'은 같아 보이지만 다른 값이다. 타입마다 생성한 목적과 용도가 서로 다르며 확보해야할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다르다. 

## 숫자 타입
``` javascript
// 모두 숫자 타입
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

- ECMAScript 사양에 따르면, 숫자 타입은 배정밀도 64비트 부동소수점 형식 을 따른다. 즉 모든 수를 실수로 처리하며, 정수만을 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다. 
- Infinity: 양의 무한대
- -Infinity: 음의 무한대
- NaN: 산술 연산 불가(not-a-number)

``` javascript
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity 
console.log(1 * 'String'); //NaN
```

### 부동소수점
0.1 + 0.2 !=== 0.3

**원인**

- 우리는 보통 계산을 할 때 '10진법'을 사용하지만, 우리와 다르게 컴퓨터는 계산을 할 때 0과 1만 사용하는 '2진법'을 사용한다. 그래서 10진법을 2진법으로 바꾸는 변환과정이 필요한데, 소수 중 일부는 이 과정에서 무한소수가 되어버린다. 하지만 컴퓨터 메모리에는 한계가 있어서 무한 소수를 다 담지 못하고 중간에 잘라서 유한 소수로 저장해버린다. 바로 이 과정에서 미세한 오차가 발생하는 것이다.

**해결 방법**

1. toFixed() 메서드
- toFixed()는 입력받은 숫자를, 매개변수만큼 자리수를 반올림해 String으로 반환해주는 함수이다.
- String으로 반환하기 때문에, 'number '타입으로 사용하고 싶다면 Number() 메서드를 한번 더 사용해서 숫자로 변환해줘야 한다.
``` javascript
let result = (0.1 + 0.2).toFixed(1); 
Number(result); 
// 0.3
```
2. Math.round() 메서드
- Math.round()는 '반올림'을 해주는 함수이다. 매개변수로 들어온 값을 반올림한 후, 가장 가까운 정수 값을 반환한다.
``` javascript
Math.round(20.49); 
// 20 
Math.round((0.1 + 0.2) * 10) / 10; 
// 0.3
```
## 문자열 타입
문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 

- 문자열은 작은따옴표(''), 큰따옴표("") 또는 백틱(``)으로 텍스트를 감싼다.

``` javascript
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱
```

## 템플릿 리터럴
- ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.
- 템플릿 리터럴은 멀티라인 문자열, 표현식 문자열등 편리한 문자열 처리 기능을 제공한다. 
- 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리한다. 
- 템플릿 리터럴은 백틱(``)을 사용해 표현한다.

### 멀티라인 문자열
``` javascript
// 일반 문자열 내에서는 줄바꿈이 허용되지 않는다.
var str = 'Hello
world.';
// Error 
```

``` javascript
// 그래서 줄바꿈과 들여쓰기가 적용된 HTML 문자열을 작성시 이스케이프 시퀀스를 사용해야 한다.
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);
```
-> 출력 결과
``` html
<ul>
    <li><a href="#">HOME</a></li>
</ul>
```

일반 문자열과는 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.

``` javascript
var template = `<ul>
    <li><a href="#">HOME</a></li>
</ul>`;

console.log(template);
```

-> 출력 결과

``` html
<ul>
    <li><a href="#">HOME</a></li>
</ul>
```

>> 이스케이프 시퀀스란 프로그래밍 언어 특성상 표현할 수 없는 기능, 문자를 표현해주며, 컴퓨터를 제어하는 목적으로 사용되는 특수한 문자이다.

![이스케이프 시퀀스](https://velog.velcdn.com/images/samuel_/post/8d95d80d-8d08-425d-9d0f-0b5dd5dda35f/image.png)

### 표현식 문자열
문자열은 문자열 연산자 +를 사용해 연결할 수 있다. 

``` javascript
var first = 'min-ju';
var last = 'Kim';

console.log('my name is' + first + ' ' + last '.') // my name is min-ju Kim.
```
표현식을 삽입하려면 ${}으로 표현식을 감싼다.
``` javascript
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```

## 불린 타입
불린 타입의 값은 논리적 참, 거짓을 나타내는 true와 false뿐이다. 

``` javascript
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

## undefined 타입
undefined 타입의 값은 undefined가 유일하며, 직역하면 "정의되지 않은"이라는 뜻을 가지고 있다.

- 자바스크립트에서 var로 선언한 변수는 암묵적으로 undefined로 초기화한다.
- 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태가 아닌 undefined 로 초기화
- 따라서, 변수를 선언한 이후 값을 할당하지 않은 변수는 참조하면 → undefined
- undefined는 개발자가 의도적으로 변수에 할당한다면 본래의 취지에 어긋날뿐더러 혼란을 줄 수 있어 권장하지 않는다. 

## null 타입
null 타입의 값은 null 값이 유일하며, 프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)할때 사용한다. 

``` html
<!DOCTYPE html>
<html>
<body>
  <script>
    var element = document.querySelector('.myClass');

    // HTMl 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다.
    console.log(element); // null
  </script>
</body>
</html>
```

## 심볼 타입
심볼은 ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 심볼 값은 다른값과 중복되지 않는 유일무이한 값이라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다. 

- 심볼은 symbol 함수를 호출해 생성하며, 이 때 생성된 심볼 값은 외부에 노출되지 않으며, 다른 값과 중복되지 않는다. 

``` javascript
// 심볼 값 생성
let key = symbol('key');
console.log(typeof key); //symbol

// 객체 생성
let obj = {};

// 이름이 충돌한 위험이 없는 유일무이한 값인 심볼을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); //value

// 심볼은 유일성이 보장되는 자료형이기 때문에, 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값이 다르다.
let id1 = Symbol("id");
let id2 = Symbol("id");

console.log(id1 === id2); // false
```

- Symbol.for() 메소드
인자로 전달받은 문자열 값을 키로 갖는 심볼을 전역 심볼 레지스트리에서 찾아 반환하고, 탐색에 실패한다면 그 문자열 값을 키로 갖는 심볼을 새로 생성하여 전역 심볼 레지스트리에 저장한 뒤 이를 반환한다.
``` javascript
const sym1 = Symbol.for('foo');  // Create symbol . 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 없으면 새로운 Symbol 생성
const sym2 = Symbol.for('foo');  // Reuse symbol . 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 있으면 해당 Symbol을 반환

console.log(sym1 === sym2);  // true
```

- Symbol.keyFor() 메소드
인자로 전달받은 심볼을 전역 심볼 레지스트리에서 찾고, 그 심볼의 키를 반환하고, 탐색에 실패한다면 undefined를 반환한다.
``` javascript
const unsharedSym = Symbol('foo');
const symKey1 = Symbol.keyFor(unsharedSym);
console.log(symKey1);  // undefined

const sharedSym = Symbol.for('foo');
const symKey2 = Symbol.keyFor(sharedSym);
console.log(symKey2);  // foo
```

## 객체 타입 
- 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. 

>> 객체란 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.

## 데이터 타입의 필요성
1. 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해 
2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해 

## 동적 타이핑

### 동적 타입 언어와 정적 타입 언어
- 자바나 C같은 정적 타입언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야한다. 이를 **명시적 타입 선언** 이라고 한다. 

- 자바스크립트는 정적 타입언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 또한, 자바스크립트의 변수는 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 

**동적 타이핑**

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되며 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 

### 동적 타입 언어와 변수
- 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 편리하게 사용할 수 있으나, 단점이 있다.

**동적 타입의 단점**
- 변수 값이 언제든 변경될 수 있기에 복잡한 프로그램에선 변화하는 변수 값을 추적하기 어려울 수 있다.
- 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
- 따라서 동적 타입 언어의 변수는 값을 확인하기 전까지는 타입을 확신할 수 없다. 
- 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 
>> 즉, 숫자 타입의 변수일 것이라고 예측했지만, 사실은 문자열 타입의 변수일 수도 있다는 말이다.

-> 이렇기에 동적 타입 언어는 **유연성은 높지만 신뢰성이 떨어진다.**

**변수를 사용할 때 주의할 사항**
- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. -> 변수의 값은 재할당에 의해 언제든 변경될 수 있기에 변수의 개수가 많을수록 오류가 발생할 확률이 높아진다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야한다. -> 변수의 유효 범위가 넓으면 오류 발생 확률이 높아진다.
- 전역 변수는 최대한 사용하지 않는다. -> 어디서든지 참조/변경 가능한 전역 변수는 값이 변경될 가능성이 높고 코드에 영향을 줄 확률이 높아진다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. -> 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들고, 이는 협업과 생산성 향상에 도움을 준다. 

### 원시타입과 객체 타입
원시타입)
``` javascript
let a = 1
let b = a
 
b = 2
 
console.log('b:', b);
console.log('a:', a);
 
/*
b: 2
a: 1
*/
```

객체 타입)
``` javascript
let a = {
    name: 'Object',
    color: 'blue'
}
let b = a;
 
b.name = 'primitive';
 
console.log('b:', b);
console.log('a:', a);
 
/*
b: { name: 'primitive', color: 'blue' }
a: { name: 'primitive', color: 'blue' }
*/
```

객체 타입은 래퍼런스 주소를 복사(참조 값이 복사)해 할당해주기 때문에 b에서 name을 재할당해주게 되면 a 변수에서도 name이 같이 바뀌게 된다.

## Number.EPSILON

```
Number.EPSILON = 2.220446049250313e-16
```
Number.EPSILON은 오차없이 나타낼 수 있는 가장 작은 양의 소수를 나타낸다.

``` javascript
let result = 0.1 + 0.2 //0.30000000000000004
console.log(0.00000000000000004 < Number.EPSILON)
```
Number.EPSILON 보다도 작다면 무시해도 되는 오차다.

```
Number.EPSILON
```